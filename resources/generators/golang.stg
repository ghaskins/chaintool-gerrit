primary(base, system, provides) ::=
<<
<!
!-------------------------------------------------------------------------------------------------
! primary - main entry point for golang generator
!-------------------------------------------------------------------------------------------------
!
! This template is responsible for generating the primary golang stub that bridges between the
! Hyperledger fabric and chaincode.
!
!-------------------------------------------------------------------------------------------------
!>
/* Generated by chaintool.  DO NOT EDIT */

package ccs

import (
       	"errors"
        "regexp"
        "strconv"

        <if(system)>"github.com/hyperledger/fabric/core/system_chaincode/api"<endif>
	"github.com/hyperledger/fabric/core/chaincode/shim"
        pb "github.com/hyperledger/fabric/protos/peer"
        "<base>/ccs/api"
)

type Interfaces map[string]interface{}
type Dispatchers map[string]api.Dispatcher

type stubHandler struct {
     dispatchers Dispatchers
}

var functionspec = regexp.MustCompile("([a-zA-Z0-9.]*)/fcn/([0-9]*)")

// Initialization function, called only once
func (self *stubHandler) Init(stub shim.ChaincodeStubInterface) pb.Response {

	function, args := stub.GetFunctionAndParameters()

	if len(args) != 1 {
		return shim.Error("Expected exactly one argument")
	}

        if function != "init" {
               return shim.Error("Function must be \"init\"")
        }

        dispatcher, ok := self.dispatchers["appinit"]
        if !ok {
               return shim.Error("Interface not found")
        }

        return dispatcher.Dispatch(stub, 1, args[0])
}

// Callback representing the invocation of a chaincode
func (self *stubHandler) Invoke(stub shim.ChaincodeStubInterface) pb.Response {

	function, args := stub.GetFunctionAndParameters()

        var params string;

	if len(args) > 0 {
		params = args[0]
	}

	dispatcher, index, err := self.decodeFunction(function)
	if err != nil {
		return shim.Error(err.Error())
	}

        return dispatcher.Dispatch(stub, index, params)
}

func (self *stubHandler) decodeFunction(function string) (api.Dispatcher, int, error) {

        spec := functionspec.FindAllStringSubmatch(function, -1)
	if spec == nil {
		return nil, 0, errors.New("Could not parse function name")
	}

	dispatcher, ok := self.dispatchers[spec[0][1]]
	if !ok {
		return nil, 0, errors.New("Interface not found")
	}

 	index, err := strconv.Atoi(spec[0][2])
	if err != nil {
		return nil, 0, errors.New("Could not convert function index")
	}

	return dispatcher, index, nil
}

func (self *stubHandler) addDispatcher(name string, intf interface{}) error {

        dispatcher, err := api.Create(name, intf)
        if err != nil {
               return err
        }

        self.dispatchers[name] = dispatcher
        return nil
}

func Start(interfaces Interfaces) error {

       metadata := &ChaincodeMetaData{}
       handler := &stubHandler{dispatchers: make(Dispatchers)}

       // Install our metadata impl first so that we give the user a chance to subclass and override
       if err := handler.addDispatcher("org.hyperledger.chaintool.meta", metadata); err != nil {
		return err
       }

       // Install all of the declared interfaces
       for name, intf := range interfaces {
           if err := handler.addDispatcher(name, intf); err != nil {
              return err
           }
       }

       <if(system)>
       api.RegisterSysCC("<system>", handler)
       <else>
       err := shim.Start(handler)
       if err != nil {
               return err
       }
       <endif>

       return nil
}
<!
!-------------------------------------------------------------------------------------------------
! end of primary template.
!-------------------------------------------------------------------------------------------------
!>
>>

api() ::=
<<
<!
!-------------------------------------------------------------------------------------------------
! api
!-------------------------------------------------------------------------------------------------
!
! This template defines an API between interface stubs and the common chaincode-support stub
!
!-------------------------------------------------------------------------------------------------
!>
/* Generated by chaintool.  DO NOT EDIT */

package api

import (
        "errors"
	"github.com/hyperledger/fabric/core/chaincode/shim"
        pb "github.com/hyperledger/fabric/protos/peer"
)

type Dispatcher interface {
     Dispatch(stub shim.ChaincodeStubInterface, function int, params string) pb.Response
}

type Factory interface {
     Create(intf interface{}) (Dispatcher, error)
}

var factories = make(map[string]Factory)

func Register(name string, factory Factory) error {
     factories[name] = factory
     return nil
}

func Create(name string, intf interface{}) (Dispatcher, error) {
     factory, ok := factories[name]
     if !ok {
        return nil, errors.New("Factory not found")
     }

     return factory.Create(intf)
}
>>

metafact(fact) ::= "&meta.Facts_Fact{Name: \"<fact.name>\", Value: \"<fact.value>\"},"

metadata(facts, provides) ::=
<<
<!
!-------------------------------------------------------------------------------------------------
! metadata
!-------------------------------------------------------------------------------------------------
!
! This template defines our metadata interface, allowing clients to query us for things like
! a list of the interfaces we support
!
!-------------------------------------------------------------------------------------------------
!>
package ccs

import (
        "errors"
	"github.com/hyperledger/fabric/core/chaincode/shim"
	"hyperledger/cci/org/hyperledger/chaintool/meta"
)

var interfaces = map[string][]byte {
        <provides.values:{intf|"<intf.name>": []byte("<intf.bytes>"),}; separator="\n">
}

var facts = &meta.Facts {
        Facts: []*meta.Facts_Fact {
               <facts.values:{fact|<metafact(fact)>}; separator="\n">
        },
}

type ChaincodeMetaData struct {
}

func (self *ChaincodeMetaData) GetInterfaces(stub shim.ChaincodeStubInterface, params *meta.GetInterfacesParams) (*meta.Interfaces, error) {

	response := &meta.Interfaces{}
	for name, data := range interfaces {
		desc := &meta.InterfaceDescriptor{Name: name}

		if params.IncludeContent {
			desc.Data = data
		}

		response.Descriptors = append(response.Descriptors, desc)
	}

	return response, nil
}

func (self *ChaincodeMetaData) GetInterface(stub shim.ChaincodeStubInterface, params *meta.GetInterfaceParams) (*meta.InterfaceDescriptor, error) {

	intf, ok := interfaces[params.Name]
	if !ok {
		return nil, errors.New("Interface " + params.Name + " not found")
	}

	return &meta.InterfaceDescriptor{Data: intf}, nil
}

func (self *ChaincodeMetaData) GetFacts(stub shim.ChaincodeStubInterface, params *meta.GetFactsParams) (*meta.Facts, error) {

	return facts, nil
}
>>

server(base, intf) ::=
<<
<!
!-------------------------------------------------------------------------------------------------
! server
!-------------------------------------------------------------------------------------------------
!
! This template is responsible for generating the interface-specific golang provider stub
!
!-------------------------------------------------------------------------------------------------
!>
/* Generated by chaintool.  DO NOT EDIT */

package <intf.package>

import (
	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/core/chaincode/shim"
        pb "github.com/hyperledger/fabric/protos/peer"
        "<base>/ccs/api"
        "encoding/base64"
        "fmt"
)

type CCInterface interface {
     <declarefunctions(intf, intf.functions)>
}


type stubImpl struct {
     intf CCInterface
}

// Factory mechanics
type factoryImpl struct {
}

func init() {
     self := &factoryImpl{}
     api.Register("<intf.name>", self)
}

func (self *factoryImpl) Create(intf interface{}) (api.Dispatcher, error) {
     return &stubImpl{intf: intf.(CCInterface)}, nil
}

func (self *stubImpl) Dispatch(stub shim.ChaincodeStubInterface, function int, params string) pb.Response {
        // Handle different functions
        switch {
        <dispatchfunctions(intf, intf.functions)>
        default:
                return shim.Error("Received unknown function invocation")
        }
}

/* Server stubs */
<implementservers(intf, intf.functions)>

<!
!-------------------------------------------------------------------------------------------------
! end of server template.
!-------------------------------------------------------------------------------------------------
!>
>>

client(base, intf) ::=
<<
<!
!-------------------------------------------------------------------------------------------------
! client
!-------------------------------------------------------------------------------------------------
!
! This template is responsible for generating the interface-specific golang consumer stub
!
!-------------------------------------------------------------------------------------------------
!>
/* Generated by chaintool.  DO NOT EDIT */

package <intf.package>

import (
	"github.com/golang/protobuf/proto"
	"github.com/hyperledger/fabric/core/chaincode/shim"
        "encoding/base64"
        "fmt"
)

/* Client stubs */
<implementclients(intf, intf.functions)>

<!
!-------------------------------------------------------------------------------------------------
! end of client template.
!-------------------------------------------------------------------------------------------------
!>
>>

compositename(intf, func)          ::= "\"<intf.name>/fcn/<func.index>\""
implementservers(intf, functions)  ::= "<functions.values:{x | <implementserver(intf, x)> }; separator=\"\n\">"
implementclients(intf, functions)  ::= "<functions.values:{x | <implementclient(intf, x)> }; separator=\"\n\">"
dispatchfunctions(intf, functions) ::= "<functions.values:{x | <dispatchfunction(intf, x)> }; separator=\"\n\">"

declarefunctions(intf, functions) ::=
<<
<functions.values:{x | <x.name>(shim.ChaincodeStubInterface<if(x.param)>, *<x.param><endif>) <if(x.rettype)>(*<x.rettype>, error)<else>error<endif> }; separator="\n">
>>

dispatchfunction(intf, func) ::=
<<
case function == <func.index>:
     return self.proxy<func.name>(stub, params)
>>

implementserver(intf, func) ::=
<<

func (self *stubImpl) proxy<func.name>(stub shim.ChaincodeStubInterface, _params string) pb.Response {

     var err error;

     <if(func.param)>
     params := &<func.param>{}
     _pbinput, err := base64.StdEncoding.DecodeString(_params)
     if (err != nil) {
        return shim.Error(fmt.Sprintf("base64 decode error: %s", err))
     }
     err = proto.Unmarshal(_pbinput, params)
     if (err != nil) {
        return shim.Error(fmt.Sprintf("protobuf unmarshal error: %s", err))
     }
     <endif>

     <if(func.rettype)>result, err := <else>err = <endif>self.intf.<func.name>(stub<if(func.param)>, params<endif>)
     if (err != nil) {
        return shim.Error(err.Error())
     }

     <if(func.rettype)>
     _pboutput, err := proto.Marshal(result)
     if (err != nil) {
        return shim.Error(fmt.Sprintf("protobuf marshal error: %s", err))
     }
     _result := base64.StdEncoding.EncodeToString(_pboutput)
     return shim.Success([]byte(_result))
     <else>
     return shim.Success(nil)
     <endif>
}

>>

implementclient(intf, func) ::=
<<

func <func.name>(stub shim.ChaincodeStubInterface, chaincodeName string<if(func.param)>, params *<func.param><endif>) <\\>
<if(func.rettype)>(*<func.rettype>, error)<else>error<endif> {

     <if(func.param)>
     args := make([][]byte, 2)
     <else>
     args := make([][]byte, 1)
     <endif>
     var err error

     args[0] = []byte(<compositename(intf, func)>)

     <if(func.param)>
     _pboutput, err := proto.Marshal(params)
     if (err != nil) {
          return <if(func.rettype)>nil, <endif>err
     }

     args[1] = make([]byte, base64.StdEncoding.EncodedLen(len(_pboutput)))
     base64.StdEncoding.Encode(args[1], _pboutput)
     <endif>

      resp := stub.InvokeChaincode(chaincodeName, args)
      if resp.Status \< shim.ERROR {
         <if(func.rettype)>
	result := &<func.rettype>{}
	_pbinput, err := base64.StdEncoding.DecodeString(string(resp.Payload))
	if (err != nil) {
	     return nil, fmt.Errorf("Error decoding base64 return value: %s", err)
	}
	err = proto.Unmarshal(_pbinput, result)
	if (err != nil) {
	     return nil, fmt.Errorf("Error unmarshalling return value: %s", err)
	}
	return result, nil
	<else>
	return nil
	<endif>
     }

     return <if(func.rettype)>nil, <endif>fmt.Errorf("RPC failure: %s", resp.Message)
}

>>
